Writing unit tests that change how you think about your code

Test driven development can be a valuable technique for code verification, analysis, regression testing, and documentation. Unit tests are a cost effective way to ensure all of the paths of your code are exercised and run as you intend. Many tools and frameworks that are freely available can make writing these tests and verifying code coverage become much easier. In this blog I'll demonstrate an API that must meet a set of requirements, discuss design tradeoffs, walk through unit test examples, and discuss how these tests can be beneficial.  Before jumping into this concrete example, it's important to point out a few things. Firstly unit testing in object oriented programming is intended to test each object in isolation of other objects. While it is also necessary to test objects working together, strictly speaking these would be called integration tests. Secondly, there really is no gold standard for unit testing conventions but the more readable, concise, and consistent they are the better. Thirdly there are always three primary steps in every unit test no matter how they are written: (1) setup (2) exercise (3) verify. Each of these steps should ideally be run regardless of the test's outcome. Clearly labeling each of these steps and providing a concise description of the scenario being tested (either in the test method name or a comment) can help with readability of your tests. For further guidance on testing conventions I strongly recommend http://xunitpatterns.com/.

Below is the specification of what the API demonstrated in this example needs to do. The API's purpose is to track purchases in a store inventory system:
1. Endpoint(s) to store and retrieve customer purchases, each in the following json format:
    { "customerID" : "[customerID string]", "date" : ["purchaseDate"], "PurchasedItems" : [{"itemID": "[itemID string]", "itemCost": [cost integer]}] }
2. Endpoint to receive list of all customers who made purchases
3. Endpoint to receive audit trail of purchases for a customer. Includes the total spent for each purchase and ranked in descending order by purchase cost
4. Endpoint which retrieves the total amount spent for a customer across all purchases

I'll demonstrate a class which contains all of the business logic for the above functionality and walk through the code and unit tests for two of these endpoints. This API is built using Java Spring Framework and the H2 in memory database. For the unit tests we use the Mockito framework (TODO link)and a code coverage tool called Jacoco (TODO link). When developing

The first endpoint we will cover allows making a purchase. Based on requirements 2, 3, and 4 we need not only a record of the purchases but also of the customers who made them. Thus, as a purchase is made we also store new customers into a table. There are two paths through the code which we are testing: (1) where the customer is stored and the the purchase is saved, and (2) where the customer is found to already exist (so not saved) and the purchase is saved. Next I will cover a strategy to test both of these scenarios.

Scenario 1 (customer is stored and the purchase is saved)

Setup:

Lets start by looking at the setup portion of this unit test. We first need to instantiate the object being tested. Since all tests will require this step I have moved the logic into a function annotated with @BeforeEach which informs Junit to run this function before each test. In this setup step we invoke the tested object's constructor by passing mocks of each dependency (line 39). These mock versions of the dependencies are created using the Mockito library. Through the use of various Mockito function such as "when" on these dependencies we can tell them to behave in ways that will allow us to exercise the paths of code that need to be tested.

Firstly, I tell the customer lookup operation that it will indicate there is no existing customer (line 81). I then tell stub a method that translates the purchase input into a database object(line 85). And lastly I stub the save operation itself to also return the database object as if it was saved correctly (line 88).

Exercise:
Whethe test is run I will make sure that this translated database object is returned by the purchase method as the result. Note that I do not care about the contents of this object because the translation operation is handled by a dependency which is tested separately. What I do care about verifying in this test is that the expected result is returned and that the object under test delegated the necessary lookup, translation, and storage to its dependencies correctly.

Verify:

We'll also cover a scenario where robust unit tests prevent a new coder from introducing bugs to legacy features.