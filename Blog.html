Writing unit tests that change how you think about your code

Test driven development can be a valuable technique for code analysis, regression testing, and documentation. Many tools and frameworks that are freely available can make writing these tests and verifying code coverage become much easier. Unit tests are most useful when they are used consistently and in a standard and readable way.

In this blog I will walk through an example of where unit tests change how we think about code. We'll also cover a scenario where robusts unit tests prevent a new coder from introducing bugs to legacy features.

Below is the specification of what the API demonstrated in this example needs to do. The API's purpose is to track purchases in a store inventory system:
- Endpoint(s) to store and retrieve customer purchases, each in the following json format:
    { "customerID" : "[customerID string]", "date" : ["purchaseDate"], "PurchasedItems" : [{"itemID": "[itemID string]", "itemCost": [cost integer]}] }
- Endpoint to receive list of all customers who made purchases
- Endpoint to receive audit trail of purchases for a customer. Includes the total spent for each purchase and ranked in descending order by purchase cost
- Endpoint which retrieves the total amount spent for a customer across all purchases

For purposes of this blog we will jump into a class which contains all of the business logic for the above functionality and walk through its functionality and unit testing approach. To see the full source code, visit ____. This API is built in Java and leveraging the Spring framework and the H2 in memory database. For the unit tests, Mockito framework and a code coverage tool called ___ are leveraged.


