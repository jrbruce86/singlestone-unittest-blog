Writing unit tests that change how you think about your code

Test driven development can be a valuable technique for code analysis, regression testing, and documentation. Many tools and frameworks that are freely available can make writing these tests and verifying code coverage become much easier. Unit tests are most useful when they are used consistently and in a standard and readable way.

In this blog I will walk through an example of where unit tests change how we think about code. We'll also cover a scenario where robusts unit tests prevent a new coder from introducing bugs to legacy features.

Below is the specification of what the API demonstrated in this example needs to do. The API's purpose is to track purchases in a store inventory system:
1. Endpoint(s) to store and retrieve customer purchases, each in the following json format:
    { "customerID" : "[customerID string]", "date" : ["purchaseDate"], "PurchasedItems" : [{"itemID": "[itemID string]", "itemCost": [cost integer]}] }
2. Endpoint to receive list of all customers who made purchases
3. Endpoint to receive audit trail of purchases for a customer. Includes the total spent for each purchase and ranked in descending order by purchase cost
4. Endpoint which retrieves the total amount spent for a customer across all purchases

Lets jump into a class which contains all of the business logic for the above functionality and walk through the code and unit tests for two of these endpoints. To see the full source code, visit ____. This API is built using Java Spring Framework and the H2 in memory database. For the unit tests I used the Mockito framework (TODO link)and a code coverage tool called Jacoco (TODO link).

The first endpoint we will cover is relatively simple and allows making a purchase. Based on requirements 2, 3, and 4 we need not only a record of the purchases but also of the customers who made them. Thus, as a purchase is made I also store new customers into a table. There are two "happy paths" through the code: (1) where the customer is stored and the the purchase is saved, and (2) where the customer is found to already exist and the purchase is saved. Next I will cover a strategy to test both of these scenarios.

Before jumping into the unit tests, it's important to point out a few things. Firstly the puprose of unit testing in object oriented programming is to test each object in isolation of other objects. Testing multiple objects in concert is called integration testing. Secondly, there really is no gold standard for unit testing conventions but the more readable, concise, and consistent they are the better. There are always three primary steps in every unit tests no matter how they are written: (1) setup (2) exercise (3) verify. Each of these steps should ideally be run regardless of the test's outcome. The approach I have adopted is to clearly label each of these steps in my tests and to name the function of my tests based on the scenario being tested. For further guidance on testing conventions I strongly recommend http://xunitpatterns.com/, the concepts covered apply to any language and also the clean code talks https://www.youtube.com/watch?v=RlfLCWKxHJ0.

Lets start by looking at the setup of the first happy path scenario (customer is stored and purchase is saved). For the setup step it is necessary to create the object being tested along with its constructor dependencies. Since all tests will require this step I have moved the logic of this step into a function annotated with @BeforeEach. This annotation informs Junit to run this function before each test. By newly constructing the object under test each time I gain more confidence that each test is independent of others. I "inject" mocks of each dependency into the constructor on line 39. For purposes of unit testing these dependencies are imitations of the actual objects used in code which can be customized with useful Mockito framework functions which we will cover in this blog, in order to test our scenarios.

Next looking to the first happy path scenario test, notice the @Test annotation. This is needed to tell JUnit to treat the function as a unit test and should be above all unit tests. In the setup section I tell the customer lookup to indicate there is no existing customer (using the Mockito framework "when" function). Next I stub the translation and storage [continue here]
