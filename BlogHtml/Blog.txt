

<title> Writing Unit Tests That Change How You Think About Your Code </title>
<body>
<h1> Writing Unit Tests That Change How You Think About Your Code </h1>

Abstract:
Test driven development can be a valuable technique for code verification, analysis, regression testing, and documentation. Unit tests are a cost effective way to ensure all of the paths of your code are exercised and run as you intend. Many tools and frameworks that are freely available can make writing these tests and verifying code coverage become much easier. In this blog I'll demonstrate an API that must meet a set of requirements, discuss design tradeoffs, walk through unit test examples, and discuss how these tests can be beneficial.  Before jumping into this concrete example, it's important to point out a few things. Firstly unit testing in object oriented programming is intended to test each object in isolation of other objects. While it is also necessary to test objects working together, strictly speaking these would be called integration tests and are outside the scope of this blog. Secondly, there really is no gold standard for unit testing conventions but the more readable, concise, and consistent they are the better. Thirdly there are always three primary steps in every unit test no matter how they are written: (1) setup (2) exercise (3) verify. Each of these steps should ideally be run regardless of the test's outcome. Clearly labeling each of these steps and providing a concise description of the scenario being tested (either in the test method name or a comment) can help with readability of your tests. For further guidance on testing conventions please visit http://xunitpatterns.com/.

Requirements:
Below is the specification of what the API demonstrated in this example needs to do. The API's purpose is to track purchases in a store inventory system:
1. Endpoint(s) to store and retrieve customer purchases, each in the following json format:
    { "customerID" : "[customerID string]", "date" : ["purchaseDate"], "PurchasedItems" : [{"itemID": "[itemID string]", "itemCost": [cost integer]}] }
2. Endpoint to receive list of all customers who made purchases
3. Endpoint to receive audit trail of purchases for a customer. Includes the total spent for each purchase and ranked in descending order by purchase cost
4. Endpoint which retrieves the total amount spent for a customer across all purchases

Intro and tradeoff analysis:
I'll demonstrate a class which contains all of the business logic for the above functionality and walk through the code and unit tests for two of these endpoints. This API is built using the Gradle build tool, Java Spring Framework and the H2 in memory database. For the unit tests we use the Mockito framework (TODO link) and a code coverage tool called Jacoco (TODO link). When developing the code to implement and test the above requirements there are some design tradeoffs to be made. Namely should the code be written to satisfy the single responsibility principle (split up into tiny modules) or is it best to have all of the business logic in one place for enhanced readability? For this example, I have implemented nearly all of the above requirements in one class in order to simplify the implementation. This tradeoff comes at the added expense of making some of the unit tests a little more complex as we will discuss later. I encourage you to use your best judgement when analyzing these tradeoffs but in this case I decided that keeping the implementation simple would ensure enough robustness to justify the extra effort on the tests.

Scenario 1.1 (Initial purchase) and 1.2 (Subsequent purchase)

The first endpoint we will cover allows making a purchase. Based on requirements 2, 3, and 4 we need not only a record of the purchases but also of the customers who made them. Thus, as a purchase is made we also store new customers into a table if they haven't been stored yet. There are two paths through the code which we are testing: (1.1) where the customer is stored and the purchase is saved, and (1.2) where the customer is found to already exist (so not saved) and the purchase is saved. I'll demonstrate the setup, exercise, and verify steps for 1.1 and then demonstrate how some slight alterations to 1.1 will allow quickly testing 1.2 also.

Setup:
Lets start by looking at the setup portion of this unit test. We first need to instantiate the object being tested. Since all tests will require this step I have moved the logic into a function annotated with @BeforeEach which informs Junit to run this function before each test. In this setup step we invoke the tested object's constructor by passing mocks of each dependency (line 39). These mock versions of the dependencies are created using the Mockito library and through the use of various Mockito function such as "when" on we can tell these dependencies to behave in ways that will allow us to exercise the paths of code that need to be tested.

This setup step is valuable for code analysis perspecitve as figuring out how the scenario we are testing can be run requires truly thinking through and reflecting on how the code is written. In this case, firstly, I tell the customer lookup operation that it will indicate there is no existing customer (test line 81) so that the purchase method's "if" statement is entered as expected (implementation line 45). I then tell a method that translates the purchase input into a database object (test line 85) to return one that I have defined for my test so that the purchase method's save operation (implementation line 47) will receive a controlled input. And lastly I stub the save operation itself to also return that object as if it was saved correctly (line 88) so that the method itself will return a controlled input (implementation line 47).

Exercise:
When the purchase method is exercised (test line 93), we can verify that the correct path of code was executed by running the test and leveraging our code coverage tool (Jacoco) [insert picture below paragraph with caption: Output of code coverage tool, notice that the path we are executing in our test is green, the yellow shows that only 1 of 2 branches in the if statement have been run so far, the red shows paths that have not been tested]. In this case, since I am using the gradle build tool I do so by running the command "gradle test jacocoTestReport" and then opening the build/reports/jacoco/test/html/index.html. By navigating to the tested function I can see the expected scenario is tested as illustrated below.

Verify:
While the code coverage tool does confirm that the code path of the scenario is run, it cannot confirm that any of the tested code behaved in a controlled way. Through the verify section of a unit test we can verify the code behaved as expected. When looking closely at the implementation of the purchase method you will notice that it doesn't do much itself, rather it delegates responsibilities to its dependencies. E.g. the CustomerRepository findById takes the customer id and returns an empty value, the CustomerRepository saves the customer id, the DtoMapper toPurchaseRecord translates the input into a Spring JPL database object, and that object is passed into the PurchaseRecordRepository save method and returned by it. Using the Mockito "verify" along with "ArgumentCaptor" we ensure all of the aforementioned behavior occurred as expected as shown below [insert picture 1.1verify.png].

Scenario 1.2 (Subsequent purchase):
Testing the scenario where an existing customer makes a purchase only requires some slight alterations to the previous test. Namely, the CustomerRepository findById() method must now return a non-empty record and we must verify that the customer record is now not saved as shown below [insert 1.2.test.png]. Now notice that the code coverage tool reveals that we have completely covered all paths of this function [insert 1.2.coverage.png].

Conclusion:
In this blog we have walked through the implementation of and tests for a very simple endpoint in an API for storing and retrieving customer records. In the next blog we will walk through a more complex implementation and test that allows verifying the API can successfully audit the purchase and track their costs. Stay tuned!

TODO:
In a future blog we will demonstrate how a robust unit test can prevent new coders from breaking legacy features as new ones are introduced.

</body>